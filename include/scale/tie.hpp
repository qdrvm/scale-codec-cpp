/**
 * Copyright Quadrivium LLC
 * All Rights Reserved
 * SPDX-License-Identifier: Apache-2.0
 */

#pragma once

#include <array>
#include <tuple>
#include <type_traits>
#include <utility>

#define _SCALE_TIE(...)                                             \
  if constexpr (requires { [&]() { auto &[__VA_ARGS__] = v; }; }) { \
    auto &[__VA_ARGS__] = v;                                        \
    return std::tie(__VA_ARGS__);                                   \
  }

namespace scale {
  template <typename T>
    requires(requires(T t) { t.tie(); })
  auto tie(const T &v) {
    return const_cast<T &>(v).tie();
  }

  template <typename T, size_t N>
  void tie(const std::array<T, N> &);

  template <typename T>
  auto tie_struct(const T &cv) {
    auto &v = const_cast<T &>(cv);
    // clang-format off
    if constexpr (std::is_empty_v<T>) return std::tuple{};
    // generated by tie.py
    else _SCALE_TIE(v0)
    else _SCALE_TIE(v0, v1)
    else _SCALE_TIE(v0, v1, v2)
    else _SCALE_TIE(v0, v1, v2, v3)
    else _SCALE_TIE(v0, v1, v2, v3, v4)
    else _SCALE_TIE(v0, v1, v2, v3, v4, v5)
    else _SCALE_TIE(v0, v1, v2, v3, v4, v5, v6)
    else _SCALE_TIE(v0, v1, v2, v3, v4, v5, v6, v7)
    else _SCALE_TIE(v0, v1, v2, v3, v4, v5, v6, v7, v8)
    else _SCALE_TIE(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9)
    else _SCALE_TIE(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10)
    else _SCALE_TIE(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11)
    else _SCALE_TIE(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12)
    // clang-format on
  }

  auto tie(const auto &v) {
    return tie_struct(v);
  }

  template <typename T>
  using Tie = decltype(::scale::tie(std::declval<T>()));

  template <typename T>
  concept IsTie = not
  std::is_void_v<Tie<T>>;
}  // namespace scale

#undef _SCALE_TIE
